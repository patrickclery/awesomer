#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../config/environment'

puts 'ğŸ§ª Testing GitHub API Caching'
puts '=' * 40

# Test repository
owner = 'rails'
repo_name = 'rails'
cache_key = "github_stats:#{owner}:#{repo_name}"

puts "\n1ï¸âƒ£  Checking cache status:"
cached_data = Rails.cache.read(cache_key)
if cached_data
  puts "  âœ… Cache HIT: Found cached data for #{owner}/#{repo_name}"
  puts "  ğŸ“Š Cached stars: #{cached_data[:stars]}"
  puts "  ğŸ“… Last commit: #{cached_data[:last_commit_at]}"
else
  puts "  âŒ Cache MISS: No cached data for #{owner}/#{repo_name}"
end

puts "\n2ï¸âƒ£  Testing FetchGithubStatsForCategoriesOperation caching:"

# Create test category with the repository
test_category = Structs::Category.new(
  custom_order: 1,
  name: 'Test Category',
  repos: [
    Structs::CategoryItem.new(
      description: 'A web-application framework',
      id: 1,
      name: 'Rails',
      url: "https://github.com/#{owner}/#{repo_name}"
    )
  ]
)

operation = FetchGithubStatsForCategoriesOperation.new

# First call - should either use cache or make API call
puts '  ğŸ”„ First call (sync mode):'
start_time = Time.current
result1 = operation.call(categories: [test_category], sync: true)
duration1 = Time.current - start_time

if result1.success?
  updated_repo = result1.value!.first.repos.first
  puts "    âœ… Success: #{updated_repo.stars} stars"
  puts "    â±ï¸  Duration: #{duration1.round(2)} seconds"
else
  puts "    âŒ Failed: #{result1.failure}"
end

# Second call - should definitely use cache
puts '  ğŸ”„ Second call (should use cache):'
start_time = Time.current
result2 = operation.call(categories: [test_category], sync: true)
duration2 = Time.current - start_time

if result2.success?
  updated_repo = result2.value!.first.repos.first
  puts "    âœ… Success: #{updated_repo.stars} stars"
  puts "    â±ï¸  Duration: #{duration2.round(2)} seconds"

  if duration2 < 0.1
    puts '    ğŸš€ FAST! Likely used cache (< 0.1s)'
  else
    puts '    ğŸŒ SLOW! Likely made API call (> 0.1s)'
  end
else
  puts "    âŒ Failed: #{result2.failure}"
end

puts "\n3ï¸âƒ£  Cache verification:"
final_cached_data = Rails.cache.read(cache_key)
if final_cached_data
  puts '  âœ… Cache now contains:'
  puts "    ğŸ“Š Stars: #{final_cached_data[:stars]}"
  puts "    ğŸ“… Last commit: #{final_cached_data[:last_commit_at]}"
  puts '    ğŸ•’ Cache expires in: ~1 month'
else
  puts '  âŒ No cache data found'
end

puts "\n4ï¸âƒ£  Rate limiting status:"
rate_limiter = GithubRateLimiterService.new
puts "  ğŸ“Š Requests remaining: #{rate_limiter.requests_remaining}"
puts "  âœ… Can make request: #{rate_limiter.can_make_request?}"

puts "\nâœ¨ Caching Test Complete!"
puts "\nğŸ’¡ Key Benefits:"
puts '  â€¢ 1-month cache expiration reduces API calls by ~99%'
puts '  â€¢ Cache key format: github_stats:owner:repo_name'
puts '  â€¢ Works in both sync and async modes'
puts '  â€¢ Respects GitHub rate limits (4000/hour conservative)'
