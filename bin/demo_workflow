#!/usr/bin/env ruby
# frozen_string_literal: true

# Demo script to show the markdown generation workflow in action

require_relative "../config/environment"

puts "ğŸš€ Markdown Generation Workflow Demo"
puts "=" * 50

# Step 1: CLI invocation simulation
puts "\n1ï¸âƒ£  CLI Invocation (markdown_processor.rb)"
puts "   Processing repository: Polycarbohydrate/awesome-tor"

# Step 2: ProcessAwesomeListService orchestration
puts "\n2ï¸âƒ£  ProcessAwesomeListService orchestration"
puts "   âœ… Fetching README from GitHub"
puts "   âœ… Parsing markdown content"
puts "   âœ… Queueing background jobs for GitHub stats"
puts "   âœ… Generating initial markdown (without stats)"

# Simulate the service call
service = ProcessAwesomeListService.new(repo_identifier: "Polycarbohydrate/awesome-tor")
result = service.call

if result.success?
  puts "   âœ… Main processing completed successfully"
  puts "   ğŸ“„ Initial markdown file: #{result.value!}"
else
  puts "   âŒ Main processing failed: #{result.failure}"
  exit 1
end

# Step 3: Background job status
puts "\n3ï¸âƒ£  Background Job Status"

# Check pending jobs using correct SolidQueue API
total_jobs = SolidQueue::Job.count
ready_jobs = SolidQueue::ReadyExecution.count
failed_jobs = SolidQueue::FailedExecution.count
scheduled_jobs = SolidQueue::ScheduledExecution.count

puts "   ğŸ“Š Total jobs: #{total_jobs}"
puts "   ğŸ“Š Ready jobs: #{ready_jobs}"
puts "   ğŸ“Š Scheduled jobs: #{scheduled_jobs}"
puts "   ğŸ“Š Failed jobs: #{failed_jobs}"

if ready_jobs > 0 || scheduled_jobs > 0
  puts "   â³ Background jobs are queued and will process GitHub API calls"
  puts "   â³ Final markdown with stats will be generated after completion"
else
  puts "   âœ… No pending jobs (may have completed already)"
end

# Step 4: Rate limiting status
puts "\n4ï¸âƒ£  Rate Limiting Status"
rate_limiter = GithubRateLimiterService.new

begin
  can_make_request = rate_limiter.can_make_request?
  remaining = rate_limiter.requests_remaining
  
  puts "   ğŸ”’ Can make GitHub API request: #{can_make_request}"
  puts "   ğŸ“ˆ Remaining requests: #{remaining}/4000"
rescue => e
  puts "   âš ï¸  Rate limiter unavailable (Redis): #{e.message}"
end

# Step 5: Recent API requests
puts "\n5ï¸âƒ£  Recent GitHub API Activity"
recent_requests = GithubApiRequest.recent(1.hour).limit(5)

if recent_requests.any?
  puts "   ğŸ“‹ Recent API requests:"
  recent_requests.each do |req|
    status_emoji = req.response_status == 200 ? "âœ…" : "âŒ"
    puts "     #{status_emoji} #{req.endpoint} (#{req.response_status}) - #{req.requested_at.strftime('%H:%M:%S')}"
  end
else
  puts "   ğŸ“­ No recent API requests in the last hour"
end

# Step 6: Cache status
puts "\n6ï¸âƒ£  Cache Status"
cache_keys = []

# Sample some cache keys to check
sample_repos = ["Polycarbohydrate/awesome-tor", "octocat/Hello-World"]
sample_repos.each do |repo|
  cache_key = "github_stats:#{repo.gsub('/', ':')}"
  if Rails.cache.exist?(cache_key)
    cache_keys << cache_key
  end
end

if cache_keys.any?
  puts "   ğŸ’¾ Found #{cache_keys.size} cached repository stats"
  cache_keys.each { |key| puts "     ğŸ“¦ #{key}" }
else
  puts "   ğŸ“­ No cached repository stats found"
end

# Step 7: Workflow summary
puts "\n7ï¸âƒ£  Workflow Summary"
puts "   ğŸ”„ Main Flow: CLI â†’ Service â†’ Operations â†’ Initial Markdown âœ…"
puts "   ğŸ”„ Background Flow: Jobs â†’ GitHub API â†’ Stats Cache â†’ Final Markdown â³"
puts "   ğŸ›¡ï¸  Rate Limiting: Active and monitoring API usage"
puts "   ğŸ’¾ Caching: Reducing API calls by reusing stats"

puts "\n" + "=" * 50
puts "âœ¨ Demo completed! Check the generated markdown file above."
puts "ğŸ” Monitor background jobs with: bin/jobs"
puts "ğŸ“Š Check job status with: rails console â†’ SolidQueue::ReadyExecution.count" 